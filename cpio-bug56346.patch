diff -Naur cpio-2.4.2.orig/copyin.c cpio-2.4.2/copyin.c
--- cpio-2.4.2.orig/copyin.c	Wed Aug  8 17:55:32 2001
+++ cpio-2.4.2/copyin.c	Wed Aug  8 18:02:04 2001
@@ -34,6 +34,7 @@
 static void defer_copyin ();
 static void create_defered_links ();
 static void create_final_defers ();
+static struct deferment *remove_last_defered_link ();
 
 /* Return 16-bit integer I with the bytes swapped.  */
 #define swab_short(i) ((((i) << 8) & 0xff00) | (((i) >> 8) & 0x00ff))
@@ -513,6 +514,28 @@
 	    }
 	}
 
+      if (skip_file && file_hdr.c_nlink > 1 && (archive_format == arf_newascii
+	  || archive_format == arf_crcascii) && file_hdr.c_filesize > 0)
+	{
+	  /* see if we have a defered link for this file, and if so,
+	     use it to instantiate this file */
+	  struct deferment *defered_header;
+
+	  defered_header = remove_last_defered_link(&file_hdr);
+	  if (defered_header)
+	    {
+	      /* restore the old file header (name only!) */
+	      
+	      free(file_hdr.c_name);
+	      file_hdr.c_name = (char *)
+		xmalloc(strlen(defered_header->header.c_name) + 1);
+	      strcpy(file_hdr.c_name, defered_header->header.c_name);
+	      free_deferment(defered_header);
+	      
+	      skip_file = FALSE;
+	    }
+	}
+
       if (skip_file)
 	{
 	  tape_toss_input (in_file_des, file_hdr.c_filesize);
@@ -1284,6 +1307,58 @@
 	  d = d->next;
 	}
     }
+}
+
+/* We're about to skip a file that was not selected to be
+   copied in by whatever patterns were supplied. However,
+   this file is multiply linked, and we want to check to see
+   if we are supposed to copy in any of its links. If we find
+   one, remove it from the list and return it. I could also
+   probably return the first header found... */
+
+static struct deferment * 
+remove_last_defered_link (file_hdr)
+  struct new_cpio_header *file_hdr;
+{
+  struct deferment *d, *d_prev, *d_last, *d_last_prev;
+  int	ino;
+  int 	maj;
+  int   min;
+
+  ino = file_hdr->c_ino;
+  maj = file_hdr->c_dev_maj;
+  min = file_hdr->c_dev_min;
+  d = deferments;
+
+  d_last = NULL;
+  d_prev = NULL;
+
+  while (d != NULL)
+    {
+      if ( (d->header.c_ino == ino) && (d->header.c_dev_maj == maj)
+	  && (d->header.c_dev_min == min) )
+	{
+	  d_last = d;
+	  d_last_prev = d_prev;
+	}
+
+      d_prev = d;
+      d = d->next;
+    }
+
+  if (d_last)
+    {
+      if (d_last_prev == NULL)
+	{
+	  deferments = d_last->next;
+	}
+      else
+	{
+	  d_last_prev->next = d_last->next;
+	}
+    }
+
+  return d_last;
 }
 
 /* If we had a multiply linked file that really was empty then we would
